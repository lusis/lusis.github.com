--- 
name: chef-and-encrypted-data-bags-revisted
layout: post
title: Chef and Encrypted Data Bags - Revisted
time: 2011-01-05 06:04:00 -05:00
---
<p>In my previous post <a href="http://lusislog.blogspot.com/2010/12/chef-and-encrypted-data-bags.html">here</a> I described the logic behind wanting to store data in an encrypted form in our <a href="http://wiki.opscode.com/display/chef/Data+Bags">Chef data bags</a>. I also described some general encryption techniques and gotchas for making that happen.</p><p>I've since done quite a bit of work in that regard and implemented this at our company. I wanted to go over a bit of detail about how to use my solution. Fair warning, this is a long post. Lot's of scrolling.</p><h1>A little recap</h1><p>As I mentioned in my previous post, the only reliable way to do the encryption of data bag items in an automated fashion is to handle key management yourself outside of Chef. I mentioned two techniques:</p><ul><li>storing the decryption key on the server in a flat file</li><li>calling a remote resource to grab the key</li></ul><p>Essentially the biggest problem of this issue is key management and, in an optimal world, how to automate it reliably. For this demonstration, I've gone with storing a flat text file on the server. As I also said in my previous post, this assumes you tightly control access to that server. We're going with the original assumption that if a malicious person gets on your box, you're screwed no matter what.</p><h1>Creating the key file</h1><p>I used the knife command to handle my key creation for now:</p><pre><code>knife ssh '*:*' interactive<br />echo "somedecryptionstringblahblahblah" &gt; /tmp/.chef_decrypt.key<br />chmod 0640 /tmp/.chef_decrypt.key<br /></code></pre><h1>Setting up the databags and the rake tasks</h1><p>One of the previous things I mentioned is knowing when and what to encrypt. Be sensible and keep it simple. We don't want to throw out the baby with the bath water. The Chef platform has lots of neat search capabilities that we'd like to keep. In this vein, I've created a fairly opinionated method for storing the encrypted data bag items.</p><p>We're going to want to create a new databag called "passwords". The format of the data bag is VERY simple:</p><script src="https://gist.github.com/742575.js?file=svnpass.json"></script><br /><p>We have an "id" that we want to use and the plaintext value that we want to encrypt.</p><h3>Rake tasks</h3><p>In my local chef-repo, I've created a 'tasks' folder. In that folder, I've added the following file:</p><script src="https://gist.github.com/742575.js?file=encrypt_databag_item.rake"></script><br /><p>As you can see, this requires a rubygem called <a href="https://github.com/pluginaweek/encrypted_strings">encrypted_strings</a>. I've done a cursory glance over the code and I can't see anything immediately unsafe about it. It only provides an abstraction to the native OpenSSL support in Ruby with an additional String helper. However I'm not a cryptographer by any stretch so you should do your own due diligence.</p><p>At the end of your existing Rakefile, add the following:</p><pre><code>load File.join(TOPDIR, 'tasks','encrypt_databag_item.rake')<br /></code></pre><p>If you now run <em>rake -T</em> you should see the new task listed:</p><pre><code>rake encrypt_databag[databag_item]  # Encrypt a databag item in the passwords databag<br /></code></pre><p>If you didn't already create a sample data bag and item, do so now:</p><pre><code>mkdir data_bags/passwords/<br />echo '{"id":"supersecretpassword","data":"mysupersecretpassword"}' &gt; data_bags/passwords/supersecretpassword.json<br /></code></pre><p>Now we run the rake task:</p><pre><code>rake encrypt_databag[supersecretpassword]<br /><br />Found item: supersecretpassword. Encrypting<br />Encrypted data is &lt;some ugly string&gt;<br />Uploading to Chef server<br />INFO: Updated data_bag_item[supersecretpassword_crypted.json]<br /></code></pre><p>You can test that the data was uploaded successfully:</p><pre><code>knife data bag show passwords supersecretpassword<br /><br />{<br />"data": "&lt;some really ugly string&gt;",<br />"id": "supersecretpassword"<br />}<br /></code></pre><p>Additionally, you should have in your 'data_bags/passwords' directory a new file called 'supersecretpassword_crypted.json'. The reason for keeping both files around is for key management. Should you need to change your passphrase/key, you'll need the original file around to reencrypt with the new key. You can decided to remove the unencrypted file if you want as long as you have a way of recreating it.</p><h1>Using the encrypted data</h1><p>So now that we have a data bag item uploaded that we need to use, how do we get it on the client?<br />That will require two cookbooks:<br /><ul><li><a href="https://github.com/lusis/lusis-cookbooks/tree/master/databag_decrypt">databag_decrypt</a></li><li>A cookbook which needs the decrypted data. <a href="https://github.com/lusis/lusis-cookbooks/tree/master/test_decrypt">example</a></li></ul>The general idea is that, in any cookbook you need decrypted data, you essentially do three things:<br /><ul><li>include the decryption recipe</li><pre><code>include_recipe "databag_decrypt::default"<br /></code></pre><li>assign the crypted data to a value via databag search<br /><pre><code>password = search(:passwords, "id:supersecretpassword").first</pre></code></li><li>assign the decrypted data to a value for use in the rest of the recipe<br /><pre><code>decrypted_password = item_decrypt(password[:data])</pre></code></li></ul><p>From there, it's no different that any other recipe.  <a href="https://gist.github.com/765444">Here's an example</a> of how I use it to securely store Amazon S3 credentials as databag items:</p><pre><code>include_recipe "databag_decrypt::default"<br />s3_access_key = item_decrypt(search(:passwords, "id:s3_access_key").first[:data])<br />s3_secret_key = item_decrypt(search(:passwords, "id:s3_secret_key").first[:data])<br />s3_file erlang_tar_gz do<br />  bucket "our-packages"<br />  object_name erlang_file_name<br />  aws_access_key_id s3_access_key<br />  aws_secret_access_key s3_secret_key<br />  checksum erl_checksum<br />end<br /></code></pre><h1>Changing the key</h1><p>Should you need to change the key, you'll need to jump through a few hoops:<br /><ul><li>Update the passphrase on each client. Ease depends on your method of key distribution</li><li>Update the passphrase in the rake task</li><li>Reencypt all your data bag items.</li></ul>The last one can be a pain in the ass. Since Chef currently doesn't support multiple items in a data bag json file, I created a small helper script in my chef-repo called <a href="https://gist.github.com/710759">'split-em.rb'</a>.<br />I store all of my data bag items in large json files and use split-em.rb to break them into individual files. Those file I upload with knife:</p><pre><code>bin/split-em.rb -f data_bags/passwords/passwords.json -d passwords -o<br /><br />Parsing data for svnpass into file data_bags/passwords/svnpass.json<br />Parsing data for s3_access_key into file data_bags/passwords/s3_access_key.json<br />Parsing data for s3_secret_key into file data_bags/passwords/s3_secret_key.json<br />#Run the following command to load the split bags into the passwords in chef<br />for i in svnpass s3_access_key s3_secret_key; do knife data bag from file passwords $i.json; done<br /></code></pre><p>You could then run that through the rake task to reupload the encrypted data:</p><pre><code>for i in svnpass s3_access_key s3_secret_key; do rake encrypt_databag[$i]; done<br /></code></pre><h1>Limitations/Gotchas/Additional Tips</h1>Take note of the following, please.<br /><h1>Key management</h1><p>The current method of key management is somewhat cumbersome. Ideally, the passphrase should be moved outside of the rake task. Additionally, the rekey process should be made a distinct rake task. I imagine a workflow similar to this:<br /><ul><li>rake accepts a path to the encryption key</li><li>additional rake task to change the encryption key in the form of oldpassfile/newpassfile.</li><li>Existing data is decrypted using oldpassfile, reencrypted using new passfile and sent back to the chef server.</li></ul><br />Optimally, the rake task would understand the same attributes that the decryption cookbook does so it can handle key managment on the client for you. I'd also like to make the cipher selection configurable as well an integrate it into the above steps.</p><h1>Duplicate work</h1><p>Seth Falcon at Opscode is already in the process of adding official support for encrypted data bags to Chef. His method involves converting the entire databag sans "id" to YAML and encrypting it. I wholeheartedly support that effort but that would obviously require a universal upgrade to Chef as well. The purpose of my cookbook and tasks is to work with the existing version.</p><h1>AWS IAM</h1><p>If you're an Amazon EC2 user, you should start using IAM <strong>NOW</strong>. Stop putting your master credentials in to recipes and limit your risk. I've created a 'chef' user who I give limited access to certain AWS operations. You can see the policy file <a href="https://gist.github.com/766146">here</a>. It gives the chef user read-only access to 'my_bucket' and 'my_other_bucket'.<br />If you wanted to get REALLY sneaky, you could use fake two-factor authentication to store your key in S3:<br /><ul><li>Encrypt data bag items with "crediential B" password except for one item "s3_credentials"</li><li>s3_credentials (crendential A) is encrypted with a passphrase and managed similar to this article</li><li>Use transient credentials to access S3 and grab a passphrase file (credential B)</li><li>Decrypt data with secondary credentials</li></ul>You would have to heavily modify the cookbook to do this. I think the current implementation is fine.</p><h1>File-based passphrases</h1><p>I'm not a big fan of the file-based passphrase method. While we agreed that you should consider yourself screwed if someone gets on the box, that still leaves poorly coded applications running as an attack vector. Imagine you have an application that must run as root. Now it can read the passphrase. Should that application become remotely exploitable, the passphrase file is vulnerable. I'm leaning to the method of a private server that allows RESTful access to grab the key. I've already added support in the cookbook for a passphrase type of 'url'.</p><h1>Wrapup</h1><p>I think that covers anything. I'd love some feedback on what people think. We've already implemented this in a limited scope for using IAM credentials in our cookbooks. I can easily revoke those should they get compromised without having to generate all new master keys.</p><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/934985301455705990-1058121690022969196?l=lusislog.blogspot.com' alt='' /></div>
