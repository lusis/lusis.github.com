<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Zeromq and Logstash Part 2 | blog.lusis.org</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://blog.lusis.org/css/main.min.e34415025514319010e741089e6920454053855755ba465f66943ad102d2cb08.css></head><body><nav><header><div class=site-title><a href=/>blog.lusis.org</a></div></header><div class=nav-menu><a class="color-link nav-link" href=https://blog.lusis.org/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://blog.lusis.org/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>Zeromq and Logstash Part 2</h1><time>February 8, 2012</time><div><p><p>A few days ago I wrote up some notes on how we&rsquo;re making Logstash better by adding ZeroMQ as an option for inputs and outputs. That night we decided to take it a bit further and add support for ZeroMQ as a filter plugin as well.</p><p>I&rsquo;ve had a lot of people ask me what&rsquo;s so hot about ZeroMQ. It&rsquo;s hard to explain but I really would suggest you read the excellent <a href=http://zguide.zeromq.org>zguide</a>. The best way I can describe it is that it&rsquo;s sockets on steroids. Sockets that behave the way you would expect sockets to behave as opposed to the way they do now. <a href=http://www.quora.com/What-is-the-background-of-the-just-open-a-socket-meme>Just open a socket!</a>.</p><h1 id=inputs-and-outputs>Inputs and Outputs</h1><p>I&rsquo;m only going to touch briefly on inputs and outputs. They were discussed briefly previously and I have a full fledged post in the wings about it.</p><p>They essentially work like the other implementations (AMQP and Redis) with the exception that you don&rsquo;t have a broker in the middle. Let me show you:</p><pre><code>[Collector 1] ------ load balanced events ----&gt; [Indexer 1, Indexer 2, Indexer 3, Indexer 4]
[Collector 2] ------ load balanced events ----&gt; [Indexer 1, Indexer 2, Indexer 3, Indexer 4]
[Collector 3] ------ load balanced events ----&gt; [Indexer 1, Indexer 2, Indexer 3, Indexer 4]
[Collector 4] ------ load balanced events ----&gt; [Indexer 1, Indexer 2, Indexer 3, Indexer 4]
</code></pre><p>As you can see we&rsquo;re doing a pattern very similar to before. We want to send events of our nodes over to a cluster of indexers that do filtering. The difference here is that we don&rsquo;t have a broker. Not big deal, right? One less thing to worry about! You don&rsquo;t have to learn some new tool just to get some simple load balancing of workers. This works great&mldr;..until you need to scale workers.</p><p>Even using awesome configuration management, you&rsquo;ve now got to cycle all your collectors to add the new endpoints. This means lost events. This makes me unhappy. It makes you unhappy. The world is sad. Why are you doing this to us?</p><p>Luckily I&rsquo;ve been authorized by the Franklin Mint to release the source code to an enterprise class ZeroMQ broker that you can use. Not only is it enterprise class but it has built-in clustering. You can <a href=https://github.com/lusis/enterprise-zeromq-broker>grab the code here from github</a>.</p><p>Here are the configs for the logstash agents (output.conf is collector config, input.conf is indexer config):</p><p>output.conf:</p><pre tabindex=0><code>input { stdin { type =&gt; &#34;stdin&#34; } }
output {
  zeromq {
    topology =&gt; &#34;pushpull&#34;
    address =&gt; [&#34;tcp://localhost:5555&#34;, &#34;tcp://localhost:5557&#34;]
  }
}
</code></pre><p>input.conf:</p><pre tabindex=0><code>input { 
  zeromq {
    type =&gt; &#34;pull-input&#34;
    topology =&gt; &#34;pushpull&#34;
    address =&gt; [&#34;tcp://localhost:5556&#34;, &#34;tcp://localhost:5558&#34;]
    mode =&gt; &#34;client&#34;
  }
}
output { stdout { debug =&gt; true }}
</code></pre><h2 id=action-shot>Action shot</h2><p>Here&rsquo;s a shot of our fancy clustered broker in action (click to zoom):</p><p><a href=/images/posts/zeromq-part2/zeromq-broker-ss.png><img src=/images/posts/zeromq-part2/zeromq-broker-ss.png alt=zeromq-broker-ss.png></a></p><p>As you can see the two events we sent were automatically load balanced across our <em>&ldquo;brokers&rdquo;</em> which then load balanced across our indexers.</p><h2 id=what-have-we-bought-ourselves>What have we bought ourselves?</h2><p>Obviously this is all something of a joke. All we have done is point our collectors at other nodes instead of directly at our indexers. But realize that you can create 2 fixed points on your network with 8 lines of core code and use those as the static information in your indexers and collectors. You can then scale either side without ever having to update a configuration file.</p><p>I dare say you can even run those on t1.micro instances on Amazon.</p><p>Oh and if you don&rsquo;t like Ruby, write it in something else. That&rsquo;s the beauty of ZeroMQ.</p><h1 id=filters>Filters</h1><p>The thing that has me most excited is the addition of ZeroMQ as a filter to logstash. As you&rsquo;ve already seen, ZeroMQ makes it REALLY easy to wire network topologies up with complex patterns. In the inputs and outputs we&rsquo;ve exposed a few topologies that make sense. However there&rsquo;s another topology that we had not yet exposed because it didn&rsquo;t make sense - <code>reqrep</code>.</p><h2 id=reqrep>REQ/REP</h2><p><code>reqrep</code> is short for request and reply. The reason we didn&rsquo;t expose it previously is that it didn&rsquo;t really make sense with the nature of inputs and outputs. However after talking with Jordan, we decided it actually DID make sense to use it for filters. After all, filters get a request -> do something -> return a response.</p><p>If it&rsquo;s not immediately clear yet how this makes sense, I&rsquo;ve got another example for you. Let&rsquo;s take the case of needing to look something up externally to mutate a field. You COULD write a Logstash filter to do this ONE thing for you. Maybe you can make it generic enough to even submit a pull request.</p><p>Or you could use a ZeroMQ filter:</p><pre tabindex=0><code>input { stdin { type =&gt; &#34;stdin-type&#34; } }
filter { zeromq { } }
output { stdout { debug =&gt; true } }
</code></pre><p>Here&rsquo;s the code for the filter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>require <span style=color:#e6db74>&#39;rubygems&#39;</span>
</span></span><span style=display:flex><span>require <span style=color:#e6db74>&#39;ffi-rzmq&#39;</span>
</span></span><span style=display:flex><span>require <span style=color:#e6db74>&#34;json&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context <span style=color:#f92672>=</span> <span style=color:#66d9ef>ZMQ</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Context</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>socket <span style=color:#f92672>=</span> context<span style=color:#f92672>.</span>socket(<span style=color:#66d9ef>ZMQ</span><span style=color:#f92672>::</span><span style=color:#66d9ef>REP</span>)
</span></span><span style=display:flex><span>socket<span style=color:#f92672>.</span>bind(<span style=color:#e6db74>&#34;tcp://*:2121&#34;</span>)
</span></span><span style=display:flex><span>msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>puts <span style=color:#e6db74>&#34;starting up&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>true</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  socket<span style=color:#f92672>.</span>recv_string(msg)
</span></span><span style=display:flex><span>  modified_message <span style=color:#f92672>=</span> <span style=color:#66d9ef>JSON</span><span style=color:#f92672>.</span>parse(msg)
</span></span><span style=display:flex><span>  puts <span style=color:#e6db74>&#34;Message received: </span><span style=color:#e6db74>#{</span>msg<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Simulate using an external data source to </span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># to something that you need</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> modified_message<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;@source&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#e6db74>&#34;stdin://jvstratusmbp.lusis.org/&#34;</span>
</span></span><span style=display:flex><span>    puts <span style=color:#e6db74>&#34;Doing db lookup&#34;</span>
</span></span><span style=display:flex><span>    sleep <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    modified_message<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;@source&#34;</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;john&#39;s laptop&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  puts <span style=color:#e6db74>&#34;Message responded: </span><span style=color:#e6db74>#{</span>modified_message<span style=color:#f92672>.</span>to_json<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  socket<span style=color:#f92672>.</span>send_string(modified_message<span style=color:#f92672>.</span>to_json)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>By default, the filter will send the entire event over a ZeroMQ <code>REQ</code> socket to <code>tcp://localhost:2121</code>. It will then take the reply and send it up the chain to the Logstash output with the following results:</p><p><a href=/images/posts/zeromq-part2/zeromq-filter-event.png><img src=/images/posts/zeromq-part2/zeromq-filter-event.png alt=zeromq-filter-event.png></a></p><p>Alternately, you can send a single field to the filter and have it to work with:</p><pre tabindex=0><code>input { stdin { type =&gt; &#34;stdin-test&#34; } }
filter { zeromq { field =&gt; &#34;@message&#34; } }
output { stdout { debug =&gt; true }}
</code></pre><p>and the code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>require <span style=color:#e6db74>&#39;rubygems&#39;</span>
</span></span><span style=display:flex><span>require <span style=color:#e6db74>&#39;ffi-rzmq&#39;</span>
</span></span><span style=display:flex><span>require <span style=color:#e6db74>&#34;json&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context <span style=color:#f92672>=</span> <span style=color:#66d9ef>ZMQ</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Context</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>socket <span style=color:#f92672>=</span> context<span style=color:#f92672>.</span>socket(<span style=color:#66d9ef>ZMQ</span><span style=color:#f92672>::</span><span style=color:#66d9ef>REP</span>)
</span></span><span style=display:flex><span>socket<span style=color:#f92672>.</span>bind(<span style=color:#e6db74>&#34;tcp://*:2121&#34;</span>)
</span></span><span style=display:flex><span>msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>puts <span style=color:#e6db74>&#34;starting up&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>true</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  socket<span style=color:#f92672>.</span>recv_string(msg)
</span></span><span style=display:flex><span>  puts <span style=color:#e6db74>&#34;Recieved message: </span><span style=color:#e6db74>#{</span>msg<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  modified_message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this field was changed externally&#34;</span>
</span></span><span style=display:flex><span>  puts <span style=color:#e6db74>&#34;Modified message: </span><span style=color:#e6db74>#{</span>modified_message<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  socket<span style=color:#f92672>.</span>send_string(modified_message)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>and the result:</p><p><a href=/images/posts/zeromq-part2/zeromq-filter-field.png><img src=/images/posts/zeromq-part2/zeromq-filter-field.png alt=zeromq-filter-field.png></a></p><p>Many people have been asking for an <code>exec</code> filter for some time now. Dealing with that overhead is insane when coming from the JVM. By doing this type of work over ZeroMQ, there&rsquo;s much less overhead AND a reliable conduit for making it happen.</p><p>Here&rsquo;s just a few of the use cases I could think of:</p><ul><li>Artifically throttling your flow. Just use a sleep and return the original event.</li><li>Doing external lookups for replacing parts of the event</li><li>Adding arbitrary tags to a message using external criteria based on the event.</li><li>Moving underperforming filters out of logstash and into an external process that is more performant</li><li>Reducing the need to modify configs in logstash for greater uptime.</li></ul><h1 id=wrap-up>Wrap up</h1><p>All the ZeroMQ support is currently tagged experimental (hence the warnings you saw in my screenshots). It also exists in the form described only in master. If this interests you at all, please build from master and run some tests of your own. We would love the feedback and any bugs or tips you can provide are always valuable.</p></p></div><div class=page-footer></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://blog.lusis.org/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></body></html>