<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Load Balancing Logstash With Amqp | blog.lusis.org</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://blog.lusis.org/css/main.min.e34415025514319010e741089e6920454053855755ba465f66943ad102d2cb08.css></head><body><nav><header><div class=site-title><a href=/>blog.lusis.org</a></div></header><div class=nav-menu><a class="color-link nav-link" href=https://blog.lusis.org/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://blog.lusis.org/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>Load Balancing Logstash With Amqp</h1><time>January 31, 2012</time><div><p><p>AMQP in Logstash is one of the most complicated parts of the workflow. I&rsquo;ve taken it on myself, as the person with the most AMQP experience (both RabbitMQ and Qpid) to try and explain as much as need for logstash users.</p><p><a href=https://twitter.com/patrickdebois>Patrick DeBois</a> hit me up with a common logstash design pattern that I felt warranted a full detailed post.</p><p><em>Warning: This is an image heavy post. Terminal screenshots are linked to larger versions</em></p><h2 id=requirements>Requirements</h2><ul><li>No lost messages in transit/due to inputs or outputs.</li><li>Shipper-only configuration on the source</li><li>Worker-based filtering model</li><li>No duplicate messages due to transit mediums (i.e. fanout is inappropriate as all indexers would see the same message)</li><li>External ElasticSearch cluster as final destination</li></ul><h2 id=edit>EDIT</h2><p>Originally our list stated the requirements as <em>No lost messages</em> and <em>No duplicate messages</em>. I&rsquo;ve amended those with a slight modification to closer reflect the original intent. Please see <a href=http://blog.lusis.org/blog/2012/01/31/load-balancing-logstash-with-amqp/#comment-426175086>comment from Jelle Smet here</a> for details. Thanks Jelle!</p><h2 id=notes>Notes</h2><p>We&rsquo;re going to leave the details of filtering and client-side input up to the imagination.
For this use case we&rsquo;ll simply use <code>stdin</code> as our starting point. You can modify this as you see fit.
The same goes for filtering. The assumption is that your filters will be correct and not be the source of any messages NOT making it into ElasticSearch.</p><p>Each configuration will be explained so don&rsquo;t stress over it at first glance. We&rsquo;re also going to explicitly set some options for the sake of easier comprehension.</p><h1 id=client-side-agent-config>Client-side agent config</h1><pre tabindex=0><code>{
  input {
    stdin { debug =&gt; true type =&gt; &#34;host-agent-input&#34; }
  }
  output {
    amqp {
      name =&gt; &#34;logstash-exchange&#34;
      exchange_type =&gt; &#34;direct&#34;
      host =&gt; &#34;rabbitmq-server&#34;
      key =&gt; &#34;logstash-routing-key&#34;
      durable =&gt; true
      persistent =&gt; true
    }
  }
}
</code></pre><h2 id=config-explained>Config Explained</h2><p>The amqp output:</p><h3 id=name>name</h3><p>This is the name that will be provided to RabbitMQ for the exchange. By default, the Bunny driver will auto-generate a name. This won&rsquo;t work in this usecase because the consumers will need a known name. Remember exchanges are for producers. Queues are for consumers. When we wire up the indexer side, we&rsquo;ll need to know the name of the exchange to perform the binding.</p><h3 id=exchange_type>exchange_type</h3><p>For this particular design, we want to use a direct exchange. It&rsquo;s the only way we can guarantee that only one copy of a log message will be processed.</p><h3 id=key>key</h3><p>We&rsquo;re going to explicitly set the routing key as direct exchanges do not support wildcard routing key bindings. Again, we&rsquo;ll need this on the consumer side to ensure we get the right messages.</p><h3 id=durable>durable</h3><p>This setting controls if the exchange should survive RabbitMQ restarts or not.</p><h3 id=persistent>persistent</h3><p>This is for the messages. Should they be persisted to disk or not?</p><p>Note that for a fully &ldquo;no lost messages scenario&rdquo; to work in RabbitMQ, you have to jump through some hoops. This is explain more below.</p><h2 id=running-the-agent>Running the agent</h2><p>This same configuration should be used on ALL host agents where logs are being read. You can have variation in the inputs. You can have additional outputs however the amqp output stanza above will ensure that all messages will be sent to RabbitMQ.</p><h1 id=indexer-agent-config>Indexer agent config</h1><pre tabindex=0><code>input {
  amqp {
    host =&gt; &#34;rabbitmq-server&#34;
    name =&gt; &#34;indexer-queue&#34;
    exchange =&gt; &#34;logstash-exchange&#34;
    key =&gt; &#34;logstash-routing-key&#34;
    exclusive =&gt; false
    durable =&gt; true
    auto_delete =&gt; false
    type =&gt; &#34;logstash-indexer-input&#34;
  }
}

filter {
  # your filters here
}

output {
  elasticsearch {
    # your elasticsearch settings here
  }
}
</code></pre><h2 id=config-explained-1>Config explained</h2><p>The amqp input:</p><h3 id=name-1>name</h3><p>This is the name that will be provided to RabbitMQ for the queue. Again, as with exchange, we need a known name. The reason for this is that all of our indexers are going to share a common queue. This will make sense in a moment.</p><h3 id=exchange>exchange</h3><p>This should match exactly with the name of the exchange that was created before in the host-side config.</p><h3 id=key-1>key</h3><p>This should, again, match the routing key provided in the host-side configuration exactly. <code>direct</code> exchanges do NOT support wildcard routing keys. By providing a routing key, you are creating a <code>binding</code> in RabbitMQ terms. This <code>binding</code> says &ldquo;I want all messages sent to the <code>logstash-exchange</code> with a routing key of <code>logstash-routing-key</code> to be sent to the queue named <code>indexer-queue</code>.</p><h3 id=exclusive>exclusive</h3><p>As with the exchange in the host-side config, we&rsquo;re going to have multiple workers using this queue. This is another AMQP detail. When you bind a queue to an exchange, a <code>channel</code> is created for the messages to flow across. A single queue can have multiple channels. This is how our worker pool is going to operate.</p><p><strong>You do not want a different queue name for each worker despite how weird that sounds</strong></p><p>If you give each worker its own queue, then you <strong>WILL</strong> get duplicate messages. It&rsquo;s counterintuitive, I know. Just trust me. The way to ensure that multiple consumers don&rsquo;t see the same message is to use mutliple channels on the same queue.</p><h3 id=durable-1>durable</h3><p>Same as the exchange declarition, this ensures that the queue will stick around if the broker (the RabbitMQ server) restarts.</p><h3 id=auto_delete>auto_delete</h3><p>This is the setting most people miss when trying to ensure no lost messages. By default, RabbitMQ will throw away even durable queues once the last user of the queue disconnects.</p><h3 id=type>type</h3><p>This is the standard logstash requirement for inputs. They must have a <code>type</code> defined. Arbitrary string.</p><h1 id=sidebar-on-rabbitmq-message-reliability>Sidebar on RabbitMQ message reliability</h1><p>Simply put, RabbitMQ makes you jump through hoops to ensure that no message is lost. There&rsquo;s a trifecta of settings that you have to have for it to work:</p><ul><li>Your exchange must be durable with persistent messages</li><li>Your queue must be durable</li><li>Auto-delete must not be disabled</li></ul><p><strong>EVEN IF YOU DO ALL THESE THINGS, YOU CAN STILL LOSE MESSAGES!</strong></p><h2 id=order-matters>Order matters</h2><p>I know &mldr; you&rsquo;re thinking &ldquo;What the F&mdash;?&rdquo;. There is still a scenario where you can lose messages. It has to do with how you start things up.</p><ul><li>If you start the exchange side but never start the queue side, messages are dropped on the floor</li><li>You can&rsquo;t start the queue side without first starting the exchange side</li></ul><p>While RabbitMQ let&rsquo;s you predeclare exchanges and queues from the command-line, it normally only creates things when someone asks for it. Since exchanges know nothing about the consumption side of the messages (the queues), creating an exchange with all the right settings does NOT create the queue and thus no binding is ever created.</p><p>Conversely, you can&rsquo;t declare a totally durable queue when there is no exchange in place to bind against.</p><p>Follow these rules and you&rsquo;ll be okay. You only need to do it once:</p><ul><li>Start a producer (the host-side logstash agent)</li><li>Ensure via <code>rabbitmqctl</code> or the management web interface that the exchange exists</li><li>Start one of the consumers (the indexer config)</li></ul><p>Once the indexer agent has started, you will be good to go. You can shutdown the indexers and messages will start piling up. You can shut everything down - rabbitmq (with backlogged messages), the indexer agent and the host-side agent. When you start RabbitMQ, the queues, exchanges and messages will all still be there. If you start an indexer agent, it will drain the outstanding messages.</p><p>However, if you screw the configuration up you&rsquo;ll have to delete the exchange and the queue via <code>rabbitmqctl</code> or the management web interface and start over.</p><h1 id=how-it-looks-visually>How it looks visually</h1><p>There are two plugins you should install with RabbitMQ:</p><ul><li>rabbitmq_management</li><li>rabbitmq_management_visualizer</li></ul><p>The first will provide a web interface (and HTTP API!) listening on port 55672 of your RabbitMQ server. It provides a really easy way to see messages backlogged, declared exchanges/queue and pretty much everything else. Seeing as it also provides a very nice REST api to everything inside the RabbitMQ server, you&rsquo;ll want it anyway if for nothing but monitoring hooks.</p><p>The visualizer is an ad-hoc addon that helps you see the flows through the system. It&rsquo;s not as pretty as the management web interface proper but it gets the job done.</p><h1 id=starting-it-all-up>Starting it all up</h1><p>Now we can start things up</p><h2 id=producers>Producers</h2><p>We&rsquo;re going to start up our four client side agents. These will create the exchange (or alternately connect to the existing one). If you look at the management interface, you&rsquo;ll see four channels established:</p><p>Management view:
<img src=/images/posts/load-balancing-logstash-with-amqp/amqp-four-channels.png alt=amqp-four-channels.png></p><p>Visualizer view:
<img src=/images/posts/load-balancing-logstash-with-amqp/amqp-four-producers.png alt=amqp-four-producers.png></p><p>Remember that until we connect with a consumer configuration (the indexer) messages sent to these exchanges WILL be lost.</p><h2 id=consumers>Consumers</h2><p>Now we start our indexer configurations - all four of them</p><p>Now if we take a peek around the management interface and the visualizer, we start to see some cool stuff.</p><p>In the managment interface, you&rsquo;ll see eight total channels - four for the queue and four for the exchange</p><p><img src=/images/posts/load-balancing-logstash-with-amqp/amqp-eight-channels.png alt=amqp-eight-channels.png></p><p>If you click on &ldquo;Queues&rdquo; at the top and then on the entry for our <code>indexer-queue</code>, you&rsquo;ll see more details:</p><p><img src=/images/posts/load-balancing-logstash-with-amqp/amqp-indexer-queue-details.png alt=amqp-indexer-queue-details.png></p><p>But the real visual is in the visualizer tab. Click on it and then click on the <code>indexer-queue</code> on the far right</p><p><img src=/images/posts/load-balancing-logstash-with-amqp/amqp-visualizer-detail.png alt=amqp-visualizer-detail.png></p><p>You can see the lines showing the flow of messages.</p><p>One thing to make note of about RabbitMQ load balancing. Messages are load balanced across CONSUMERS not QUEUES. There&rsquo;s a subtle distinction there from RabbitMQ&rsquo;s semantic point of view.</p><h2 id=testing-the-message-flow>Testing the message flow</h2><p>Over in your terminal window, let&rsquo;s send some test messages. For this test, again, I&rsquo;m using <code>stdin</code> for my origination and <code>stdout</code> to mimic the ElasticSearch destination.</p><p>In my first input window, I&rsquo;m going just type 1 through 4 with a newline after each. This should result in each consumer getting a message round-robin style:</p><p><a href=/images/posts/load-balancing-logstash-with-amqp/load-balance-test-1.png><img src=/images/posts/load-balancing-logstash-with-amqp/load-balance-test-1.png alt=load-balance-test-1.png></a></p><p>Now I&rsquo;m going to cycle through the input windows and send a single message from each:</p><p><a href=/images/posts/load-balancing-logstash-with-amqp/load-balance-test-4.png><img src=/images/posts/load-balancing-logstash-with-amqp/load-balance-test-4.png alt=load-balance-test-4.png></a></p><p>You can see that messages 4-7 were sent round-robin style.</p><h2 id=testing-persistence>Testing persistence</h2><p>All of this is for naught if we lose messages because our workers are offline. Let&rsquo;s shutdown all of our workers and send a bunch of messages from each input window:</p><p><a href=/images/posts/load-balancing-logstash-with-amqp/workers-offline-terminal.png><img src=/images/posts/load-balancing-logstash-with-amqp/workers-offline-terminal.png alt=workers-offline-terminal.png></a></p><p>We sent two lines of text per window. This amounts to eight log messages that should be queued up for us. Let&rsquo;s check the management interface:</p><p><img src=/images/posts/load-balancing-logstash-with-amqp/eight-messages-waiting.png alt=eight-messages-waiting.png></p><p>Now if we stop rabbitmq entirely and restart it, those messages should still be there (along with the queue and exchanges we created).</p><p>Once you&rsquo;ve verified that, start one of the workers back up. When it comes fully online, it should drain all of the messages from the exchange:</p><p><a href=/images/posts/load-balancing-logstash-with-amqp/drained-messages.png><img src=/images/posts/load-balancing-logstash-with-amqp/drained-messages.png alt=drained-messages.png></a></p><p>Yep, there they went. The last two messages you get should be the ones from window 4. This is another basic functionality of message queue software in general. Messages should be delivered in the order in which they were recieved.</p><h1 id=one-last-diagram>One last diagram</h1><p>Here&rsquo;s a flowchart I created with Gliffy to show what the high-level overview of our setup would look like. Hope it helps and feel free to hit me up on freenode irc in the <code>#logstash</code> channel or on <a href=https://twitter.com/lusis>twitter</a>.</p><p><a href=/images/posts/load-balancing-logstash-with-amqp/gliffy-overview.png><img src=/images/posts/load-balancing-logstash-with-amqp/gliffy-overview.png alt=gliffy-overview.png></a></p><p><em>This post will eventually make its way into the <a href=http://cookbook.logstash.net>Logstash Cookbook Site</a>.</em></p></p></div><div class=page-footer></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://blog.lusis.org/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></body></html>