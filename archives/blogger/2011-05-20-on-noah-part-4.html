--- 
name: on-noah-part-4
layout: post
title: On Noah - Part 4
time: 2011-05-20 02:01:00 -04:00
---
<h1 id="on-noah---part-4">On Noah - Part 4</h1><p><em>This is the fourth part in a series on Noah. <a href="http://goo.gl/l3Mgt">Part 1</a>, <a href="http://goo.gl/Nj2TN">Part 2</a> and <a href="http://goo.gl/RsZtZ">Part 3</a> are available as well</em></p><p>In Part 1 and 2 of this series I covered background on Zookeeper and discussed the similarities and differences between it and Noah. Part 3 was about the components underneath Noah that make it tick.</p><p>This post is about the &quot;future&quot; of Noah. Since I'm a fan of Fourcast podcast, I thought it would be nice to do an immediate, medium and long term set of goals.</p><h2 id="immediate-future---the-road-to-1.0">Immediate Future - the road to 1.0</h2><p>In the most immediate future there are a few things that need to happen. These are in no specific order.</p><ul><li>General<br /><ul><li>Better test coverage ESPECIALLY around the watch subsystem</li><li>Full code comment coverage</li><li>Chef cookbooks/Puppet manifests for doing a full install</li><li>&quot;fatty&quot; installers for a standalone server</li><li>Documentation around operational best practices</li><li>Documentation around clustering, redundancy and hadr</li><li>Documentation around integration best practices</li><li>Performance testing</li></ul></li><li>Noah Server<br /><ul><li>Expiry flags and reaping for Ephemerals</li><li>Convert mime-type in Configurations to make sense</li><li>Untag and Unlink support</li><li>Refactor how you specify Redis connection information</li><li>Integrated metrics for monitoring (failed callbacks, expired ephemeral count, that kind of stuff)</li></ul></li><li>Watcher callback daemon<br /><ul><li>Make the HTTP callback plugin more flexible</li><li>Finish binscript for the watcher daemon</li></ul></li><li>Other<br /><ul><li>Finish <a href="http://goo.gl/B65aL">Boat</a></li><li>Finish NoahLite LWRP for Chef (using Boat)</li><li>A few more HTTP-based callback plugins (Rundeck, Jenkins)</li></ul></li></ul><p>Now that doesn't look like a very cool list but it's a lot of work for one person. I don't blame anyone for not getting excited about it. The goal now is to get a functional and stable application out the door that people can start using. Mind you I think it's usable now (and I'm already using it in &quot;production&quot;).</p><p>Obviously if anyone has something else they'd like to see on the list, let me know.</p><h2 id="medium-rare">Medium Rare</h2><p>So beyond that 1.0 release, what's on tap? Most of the work will probably occur around the watcher subsystem and the callback daemon. However there are a few key server changes I need to implement.</p><ul><li>Server<br /><ul><li>Full ACL support on every object at every level</li><li>Token-based and SSH key based credentialing</li><li>Optional versioning on every object at every level</li><li>Accountability/Audit trail</li><li>Implement a long-polling interface for inband watchers</li></ul></li><li>Watcher callback daemon<br /><ul><li>Decouple the callback daemon from the Ruby API of the server. Instead the daemon itself needs to be a full REST client of the Noah server</li><li>Break out the &quot;official&quot; callback daemon into a distinct package</li></ul></li><li>Clients<br /><ul><li>Sinatra Helper</li></ul></li></ul><p>Also during this period, I want to spend time building up the ecosystem as a whole. You can see a general mindmap of that <a href="https://github.com/lusis/Noah/wiki/Ecosystem">here</a>.</p><p>Going into a bit more detail...</p><h3 id="tokens-and-keys">Tokens and keys</h3><p>It's plainly clear that something which has the ability to make runtime environment changes needs to be secure. The first thing to roll off the line post-1.0 will be that functionality. Full ACL support for all entries will be enabled and in can be set at any level in the namespace just the same as Watches.</p><h3 id="versioning-and-auditing">Versioning and Auditing</h3><p>Again for all entires and levels in the namespace, versioning and auditing will be allowed. The intention is that the number of revisions and audit entries are configurable as well - not just an enable/disable bit.</p><h3 id="in-band-watches">In-band watches</h3><p>While I've lamented the fact that watches were in-band only in Zookeeper, there's a real world need for that model. The idea of long-polling functionality is something I'd actually like to have by 1.0 but likely won't happen. The intent is simply that when you call say <code>/some/path/watch</code>, you can pass an optional flag in the message stating that you want to watch that endpoint for a fixed amount of time for any changes. Optionally a way to subscribe to all changes over long-polling for a fixed amount of time is cool too.</p><h3 id="agent-changes">Agent changes</h3><p>These two are pretty high on my list. As I said, there's a workable solution with minimal tech debt going into the 1.0 release but long term, this needs to be a distinct package. A few other ideas I'm kicking around are allowing configurable filtering on WHICH callback types an agent will handle. The idea is that you can specify that this invocation only handle http callbacks while this other one handles AMQP.</p><h3 id="sinatra-helper">Sinatra Helper</h3><p>One idea I'd REALLY like to come to fruition is the Sinatra Helper. I envision it working something like this:</p><pre class="sourceCode"><code class="sourceCode ruby">    require <span class="st">'sinatra/base'</span><br /><br /><span class="kw">class</span> <span class="dt">MyApp</span> &lt; <span class="dt">Sinatra</span>::<span class="dt">Base</span><br />register <span class="dt">Noah</span>::<span class="dt">Sinatra</span><br /><br />noah_server <span class="st">&quot;http://localhost:5678&quot;</span><br />noah_node_name <span class="st">&quot;myself&quot;</span><br />noah_app_name <span class="st">&quot;MyApp&quot;</span><br />noah_token <span class="st">&quot;somerandomlongstring&quot;</span><br /><br />dynamic_get <span class="st">:database_server</span><br />dynamic_set <span class="st">:some_other_variable</span>, <span class="st">&quot;foobar&quot;</span><br />watch <span class="st">:this_other_node</span><br /><br /><span class="kw">end</span></code></pre><p>The idea is that the helper allows you to register your application very easily with Noah for other components in your environment to be know. As a byproduct, you get the ability to get/set certain configuration parameters entirely in Noah. The watch setting is kind of cool as well. What will happen is if you decide to <code>watch</code> something this way, the helper will create a random (and yes, secure) route in your application that watch events can notify. In this way, your Sinatra application can be notified of any changes and will automatically &quot;reconfigure&quot; itself.</p><p>Obviously I'd love to see other implementations of this idea for other languages and frameworks.</p><h2 id="long-term-changes">Long term changes</h2><p>There aren't so much specific list items here as general themes and ideas. While I list these as long term, I've already gotten an offer to help with some of them so they might actually get out sooner.</p><h3 id="making-noah-itself-distributed">Making Noah itself distributed</h3><p>This is something I'm VERY keen on getting accomplished and would really consider it the fruition of what Noah itself does. The idea is simply that multiple Noah servers themselves are clients of other Noah servers. I've got several ideas about how to accomplish this but I got an interesting follow up from someone on Github the other day. He asked what my plans were in this area and we had several lengthy emails back and forth including an offer to work on this particular issue.</p><p>Obviously there are a whole host of issues to consider. Race conditions in ordered delivery of Watch callbacks (getting a status &quot;down&quot; after a status &quot;up&quot; when it's supposed to be the other way around..) and eventual consistency spring to mind first.</p><p>The general architecture idea that was offered up is to use <a href="https://github.com/derekcollison/nats">NATS</a> as the mechanism for accomplishing this. In the same way that there would be AMQP callback support, there would be NATS support. Additional Noah servers would only need to know one other member to bootstrap and everything else happens using the natural flows within Noah.</p><p>The other part of that is how to handle the Redis part. The natural inclination is to use the upcoming Redis clustering but that's not something I want to do. I want each Noah server to actually include its OWN Redis instance &quot;embedded&quot; and not need to rely on any external mechanism for replication of the data. Again, the biggest validation of what Noah is designed to do is using only Noah itself to do it.</p><h3 id="move-off-redisswappable-persistence">Move off Redis/Swappable persistence</h3><p>If NATS says anything to me, it says &quot;Why do you even need Redis?&quot;. If you recall, I went with Redis because it solved multiple problems. If I can find a persistence mechanism that I can use without any external service running, I'd love to use it.</p><h3 id="zeromq">ZeroMQ</h3><p>If I were to end up moving off Redis, I'd need a cross platform and cross language way to handle the pubsub component. NATS would be the first idea but NATS is Ruby only (unless I've missed something). ZeroMQ appears to have broad language and platform support so writing custom agents in the same vein as the Redis PUBSUB method should be feasible.</p><h3 id="nanite-style-agents">Nanite-style agents</h3><p>This is more of a command-and-control topic but a set of high-performance specialized agents on systems that can watch the PUBSUB backend or listen for callbacks would be awesome. This would allow you really integrate Noah into your infrastructure beyond the application level. Use it to trigger a puppet or chef run, reboot instances or do whatever. This is really about bringing what I wanted to accomplish with Vogeler into Noah.</p><h3 id="the-paxos-question">The PAXOS question</h3><p>A lot of people have asked me about this. I'll state right now that I can only make it through about 20-30% of any reading about Paxos before my brain starts to melt. However in the interest of proving myself the fool, I think it would be possible to implement some Paxos like functionality on top of Noah. Remember that Noah is fundamentally about fully disconnected nodes. What better example of a network of unreliable processors than ones that never actually talk to each other. The problem is that the use case for doing it in Noah is fairly limited so as not to be worth it.</p><p>The grand scheme is that Noah helps enable the construction of systems where you can say &quot;This component is free to go off and operate in this way secure in the knowledge that if something it needs to know changes, someone will tell it&quot;. I did say &quot;grand&quot; didn't I? At some point, I may hit the limit of what I can do using only Ruby. Who knows.</p><h2 id="wrap-up---part-4">Wrap up - Part 4</h2><p>Again with the recap</p><ul><li>Get to 1.0 with a stable and fixed set of functionality</li><li>Nurture the Noah ecosystem</li><li>Make it easy for people to integrate Noah into thier applications</li><li>Get all meta and make Noah itself distributed using Noah</li><li>Minimize the dependencies even more</li><li>Build skynet</li></ul><p><em>I'm not kidding on that last one. Ask me about Parrot AR drones and Noah sometime</em></p><p>If you made it this far, I want to say thank you to anyone who read any or all of the parts. Please don't hesitate to contact me with any questions about the project.</p><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/934985301455705990-3728744408074428802?l=lusislog.blogspot.com' alt='' /></div>
